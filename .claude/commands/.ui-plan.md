As a senior frontend developer, your task is to create a detailed implementation plan for a new view in a web application. This plan should be comprehensive and clear enough for another frontend developer to implement the view correctly and efficiently.

First, review the following information:

2. View Description:
<view_description>
#### 2.2.3 Group Details View
- **Path:** `/groups/:groupId`
- **Main Purpose:** Main hub for all group-related activities, conditionally rendered based on user role and draw state
- **Authentication Required:** Yes
- **Authorization:** User must be participant in group

- **Key Information to Display:**

  **Always Visible:**
  - Group name
  - Organizer name (clearly labeled)
  - Participant count

  **Pre-Draw State - All Participants:**
  - Group information card (name, organizer, participant count)
  - Participant list (first name, last name, join date)
  - My Wishlist section (textarea, 1000 char limit, save button)
  - My Budget Suggestion section (optional numeric input, save button)
  - Status message: "Waiting for organizer to start the draw"

  **Pre-Draw State - Organizer Only (Additional):**
  - Invitation link card (prominent, copy-to-clipboard button)
  - Budget Management section:
    - Anonymous sorted list of budget suggestions
    - Count: "5 of 6 participants provided suggestions"
    - Final budget input field (used during draw execution)
  - Exclusion Rules section:
    - Dropdown form: Select User 1, Select User 2, Add Rule button
    - List of current rules with delete buttons
    - Real-time validation feedback
  - Participant management (remove button for each participant except organizer)
  - Draw Validation Summary:
    - Validation status (checkmark or error icon)
    - List of validation errors (if any)
  - "Execute Draw" button:
    - Disabled if validation fails
    - Confirmation dialog on click
    - Requires final budget input

  **Post-Draw State - All Participants:**
  - Group summary card (read-only):
    - Group name
    - Organizer name
    - Participant count
    - Draw completed date
  - My Assignment card (prominently displayed):
    - "You're buying a gift for:"
    - Recipient first and last name
    - Final budget (prominently displayed)
    - Recipient's wishlist (if provided, else friendly message)
    - AI Gift Suggestions section (expandable):
      - "Generate Gift Ideas" button
      - Loading state with cancellation
      - 3-5 suggestions displayed in cards
  - My Wishlist section (editable):
    - Current wishlist content
    - Edit and save functionality
    - Helper text: "Your Santa will be notified when you update"

- **Key View Components:**
  - GroupInfoCardComponent
  - ParticipantListComponent
  - WishlistEditorComponent
  - BudgetSuggestionComponent
  - InvitationLinkCardComponent (organizer only)
  - BudgetManagementComponent (organizer only)
  - ExclusionRulesComponent (organizer only)
  - DrawValidationComponent (organizer only)
  - DrawExecutionComponent (organizer only)
  - AssignmentCardComponent (post-draw)
  - GiftSuggestionsComponent (post-draw)
  - LoadingSpinnerComponent
  - ErrorAlertComponent
  - ToastComponent
  - ConfirmDialogComponent

- **UX Considerations:**
  - Single scrollable page with card-based sections
  - Conditional rendering based on isOrganizer flag and drawCompleted flag
  - Mobile: Full-width cards stacked vertically
  - Desktop: Max-width container with cards in sections
  - Real-time validation feedback for exclusion rules
  - Draw button disabled with tooltip when validation fails
  - Confirmation dialog for draw execution: "This action is permanent and cannot be undone"
  - Loading state during draw execution
  - After draw: redirect with toast "Draw completed! Check your assignment"
  - Manual refresh button for data updates
  - Empty wishlist message: "Your giftee hasn't added their wishlist yet - you'll be notified by email when they do"
  - Unsaved changes warning for wishlist and budget suggestion forms

- **Security:**
  - Authorization check: user must be participant
  - Organizer-only sections hidden from non-organizers
  - Post-draw content hidden before draw
  - Assignment shows only user's own recipient
  - Budget suggestions fully anonymous (no user attribution)
  - Invitation link only visible to organizer
  - Cannot modify participants/rules/budget after draw
</view_description>

3. User Stories:
<user_stories>
S-008: View Participant List
Title: Monitor who has joined the group

Description:
As a group organizer, I want to see a list of all participants who have joined so that I can monitor participation and ensure everyone is included.

Acceptance Criteria:
- Given I am the organizer of a group
- When I access the group management page
- Then I see a list of all participants including their names
- And I can see when each participant joined
- And I can see a total participant count
- And I can see which participants have submitted budget suggestions

Edge cases:
- List updates when new participants join (requires page refresh in MVP)
- Organizer appears in the list as a participant
- List is sorted by join date or alphabetically
</user_stories>

4. Endpoint Description:
<endpoint_description>
</endpoint_description>

5. Endpoint Implementation:
<endpoint_implementation>
@SantaVibe.Backend\SantaVibe.Api\Features\Groups\Create
</endpoint_implementation>


7. Tech Stack:
<tech_stack>
@docs/tech-stack.md  
</tech_stack>

8. UI plan:
<ui_plan>
@docs/ui-plan.md  
</ui_plan>

Before creating the final implementation plan, conduct analysis and planning inside <implementation_breakdown> tags in your thinking block. This section can be quite long, as it's important to be thorough.

In your implementation breakdown, execute the following steps:
1. For each input section (PRD, User Stories, Endpoint Description, Endpoint Implementation, Type Definitions, Tech Stack):
  - Summarize key points
 - List any requirements or constraints
 - Note any potential challenges or important issues
2. Extract and list key requirements from the PRD
3. List all needed main components, along with a brief description of their purpose, needed types, handled events, and validation conditions
4. Create a high-level component tree diagram
5. Identify required DTOs and custom ViewModel types for each view component. Explain these new types in detail, breaking down their fields and associated types.
6. Identify potential state variables and custom hooks, explaining their purpose and how they'll be used
7. List required API calls and corresponding frontend actions
8. Map each user story to specific implementation details, components, or functions
9. List user interactions and their expected outcomes
10. List conditions required by the API and how to verify them at the component level
11. Identify potential error scenarios and suggest how to handle them
12. List potential challenges related to implementing this view and suggest possible solutions

After conducting the analysis, provide an implementation plan in Markdown format with the following sections:

1. Overview: Brief summary of the view and its purpose.
2. View Routing: Specify the path where the view should be accessible.
3. Component Structure: Outline of main components and their hierarchy.
4. Component Details: For each component, describe:
 - Component description, its purpose and what it consists of
 - Main HTML elements and child components that build the component
 - Handled events
 - Validation conditions (detailed conditions, according to API)
 - Types (DTO and ViewModel) required by the component
 - Props that the component accepts from parent (component interface)
5. Types: Detailed description of types required for view implementation, including exact breakdown of any new types or view models by fields and types.
6. State Management: Detailed description of how state is managed in the view, specifying whether a custom hook is required.
7. API Integration: Explanation of how to integrate with the provided endpoint. Precisely indicate request and response types.
8. User Interactions: Detailed description of user interactions and how to handle them.
9. Conditions and Validation: Describe what conditions are verified by the interface, which components they concern, and how they affect the interface state
10. Error Handling: Description of how to handle potential errors or edge cases.
11. Implementation Steps: Step-by-step guide for implementing the view.

Ensure your plan is consistent with the PRD, user stories, and includes the provided tech stack.

The final output should be in English and saved in a file named docs/web-implementation-plan/{view-name}-view-implementation-plan.md. Do not include any analysis and planning in the final output.

Here's an example of what the output file should look like (content is to be replaced):

```markdown
# View Implementation Plan [View Name]

## 1. Overview
[Brief description of the view and its purpose]

## 2. View Routing
[Path where the view should be accessible]

## 3. Component Structure
[Outline of main components and their hierarchy]

## 4. Component Details
### [Component Name 1]
- Component description [description]
- Main elements: [description]
- Handled interactions: [list]
- Handled validation: [list, detailed]
- Types: [list]
- Props: [list]

### [Component Name 2]
[...]

## 5. Types
[Detailed description of required types]

## 6. State Management
[Description of state management in the view]

## 7. API Integration
[Explanation of integration with provided endpoint, indication of request and response types]

## 8. User Interactions
[Detailed description of user interactions]

## 9. Conditions and Validation
[Detailed description of conditions and their validation]

## 10. Error Handling
[Description of handling potential errors]

## 11. Implementation Steps
1. [Step 1]
2. [Step 2]
3. [...]
```

Begin analysis and planning now. Your final output should consist solely of the implementation plan in English in markdown format, which you will save in the docs/web-implementation-plan/{view-name}-view-implementation-plan.md file and should not duplicate or repeat any work done in the implementation breakdown.